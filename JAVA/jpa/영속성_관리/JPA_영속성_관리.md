[yeon-dodo](https://yeon-dodo.tistory.com/7)

---------
# 영속성 관리 - 내부 동작 방식

엔티티 매니저 팩토리 -> 하나만 생성해서 애플리케이션 전체에서 공유<br>
엔티티 매니저는 쓰레드간 공유 x (사용하고 버려야 한다.)<br>
**jpa의 모든 데이터 변경은 트랜잭션 안에서 실행**<br>
commit 꼭 해줘야 함

## 영속성 컨텍스트<br>
엔티티를 영구 저장하는 환경
영속 상태일때 디비에 쿼리가 날라가는게 아님.
커밋 하는 순간에 영속성 컨텍스트안에 있는게 날라감.

### 1차 캐시 
한 트랜잭션 안에서만 한번 조회한거 또 조회할 경우 쿼리 날라가지 않음.

### 동일성 보장
같은 트랜잭션안에서 똑같은걸 == 으로 비교하면 true 가 나옴.

1차 캐시로 반복 가능한 읽기 등급의 트랜잭션 격리 수준을 데이터 베이스가 아닌 애플리케이션 차원에서 제공.
 
### 트랜잰션을 지원하는 쓰기 지연
쿼리를 한번에 모았다가 한번에 날림 

### 변경감지(dirty checking)
```java
EntityManager em = emf.createEntityManager();
EntityTransaction tx = em.getTransaction();
tx.begin();

Member memberA = em.find(Member.class, "memberA")
memberA.setUserName("memeberB")
```
값을 변경할때 update 쿼리 없이 이런식으로만 사용해도 자동으로 update 쿼리가 나가고 값이 업데이트 된다.<br>
(엔티티의 값을 바꾸려면 UPDATE 쿼리가 필요할것같은데 필요없음.)


디비 커밋 시점에 flush() 호출 
-> 엔티티와 스냅샷을 비교 
-> 바뀐점이 있을때 쓰기 지연 sql 저장소에 만들어둠
-> 업데이트 쿼리를 디비에 반영하고 커밋함.

(스냅샷: 값을 읽어온 시점에 1차 캐시안에 스냅샷을 떠둠)<br>

### 플러시
영속성 컨텍스트의 변경내용들을 데이터베이스에 반영(적용,동기화)하는것
영속성 컨텍스트를 비우지 않음.
트랜잭션이라는 작업 단위가 중요 -> 커밋 직전에만 동기화하면 됨.

- 플러시 발생
  - 변경 감지
  - 수정된 엔티티 쓰기 지연 sql 저장소에 등록
  - 쓰기 지연 sql 저장소의 쿼리를 데이터베이스에 전송 (등록, 수정, 삭제 쿼리)


- 영속성 컨텍스트를 플러시하는 방법
  - `em.flush()` - 직접 호출
  - `트랜잭션 커밋` - 플러시 자동 호출
  - `JPQL 쿼리 실행` - 플러시 자동 호출

(flush() 호출시켜도 1차캐시 삭제 안됨.)


### 지연로딩
쿼리가 나중에 날라가는 것. (실무에서 중요함.)
